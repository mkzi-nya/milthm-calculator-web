<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Usage</title>

  <!-- æœ¬åœ°èµ„æºï¼ˆä¸å†æ³¨å…¥ load.jsï¼‰ -->
  <link rel="stylesheet" href="./github-markdown-dark.min.css">
  <script src="./marked.min.js"></script>
  <script src="./katex.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
  <script src="./index.umd.js"></script>
  <link rel="stylesheet" href="./github-dark.min.css">
  <script src="./highlight.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
      background: #0d1117;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }
    .container { width: 100%; max-width: 900px; }
    .markdown-body { width: 100%; overflow-wrap: break-word; }
    .katex-display {
      display: block !important;
      text-align: center;
      margin: 10px 0;
      font-size: 1em;
    }
    .toc { display: none; }
    pre, code { user-select: text; }

    .language-selector {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #222;
      padding: 5px;
      border-radius: 5px;
      cursor: pointer;
      color: white;
      font-size: 2em;
    }
    .language-menu {
      display: none;
      position: absolute;
      top: 40px;
      right: 10px;
      background: #222;
      border-radius: 5px;
      padding: 10px;
      list-style: none;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }
    .language-menu li {
      padding: 8px 12px;
      cursor: pointer;
      color: white;
    }
    .language-menu li:hover { background: #444; }

    /* é»˜è®¤éšè— devï¼ˆaaaï¼‰å¹¶å¹³æ»‘æ˜¾éšï¼›å¢åŠ  top/left è¿‡æ¸¡ç”¨äºç§»åŠ¨åŠ¨ç”» */
    div[aaa] {
      visibility: hidden;
      opacity: 0;
      transition:
        opacity 0.12s ease-in-out,
        visibility 0.12s ease-in-out,
        top 0.12s ease,
        left 0.12s ease;
    }
    div[aaa].visible {
      visibility: visible;
      opacity: 1;
    }
  </style>


<body>
  <!-- è¯­è¨€é€‰æ‹©æŒ‰é’® -->
  <div class="language-selector" onclick="toggleLanguageMenu()">ğŸŒ</div>
  <ul class="language-menu" id="language-menu">
    <li onclick="changeLanguage('zh')">ä¸­æ–‡</li>
    <li onclick="changeLanguage('zh-tw')">ç¹é«”ä¸­æ–‡</li>
    <li onclick="changeLanguage('en')">English</li>
    <li onclick="changeLanguage('ja')">æ—¥æœ¬èª</li>
    <li onclick="changeLanguage('ko')">í•œêµ­ì–´</li>
    <li onclick="changeLanguage('ru')">Ğ ÑƒÑÑĞºĞ¸Ğ¹</li>
    <li onclick="changeLanguage('es')">EspaÃ±ol</li>
    <li onclick="changeLanguage('vi')">Tiáº¿ng Viá»‡t</li>
    <li onclick="changeLanguage('ken')">â‹¿ã‚¦áµã†‘ã‚¨ã„ã‚µ</li>
  </ul>

  <div class="container">
    <article id="content" class="markdown-body"></article>
  </div>

  <script>
    // ===== Markdown & é«˜äº® & KaTeX =====
    marked.use(markedKatex());
    marked.setOptions({
      highlight: (code, lang) => {
        if (lang && hljs.getLanguage(lang)) return hljs.highlight(code, { language: lang }).value;
        return hljs.highlightAuto(code).value;
      }
    });

    function getUserLanguage() {
      const langMap = {
        "zh": "zh", "zh-cn": "zh", "zh-tw": "zh-tw",
        "en": "en", "ja": "ja", "ko": "ko", "ru": "ru",
        "es": "es", "vi": "vi", "ken": "ken"
      };
      const urlParams = new URLSearchParams(window.location.search);
      let lang = urlParams.get('lang') || navigator.language.toLowerCase();
      return langMap[lang] || "en";
    }

    function loadMarkdown() {
      const lang = getUserLanguage();
      fetch(`./usage_${lang}.md?${Date.now()}`)
        .then(res => res.text())
        .then(md => {
          // é“¾æ¥è‡ªåŠ¨è½¬ä¹‰å¤„ç†ï¼ˆä¿ç•™åŸé€»è¾‘ï¼‰
          md = md.replace(/\[([^\]]+)\]\(([^)]+)\)/g, function (match, p1, p2) {
            if (p2.startsWith('info:')) {
              const [protocol, rest] = p2.split(':', 2);
              const encodedRest = encodeURIComponent(rest);
              return `[${p1}](${protocol}:${encodedRest})`;
            }
            return `[${p1}](${p2})`;
          });
          content.innerHTML = marked.parse(md, { headerIds: true, mangle: false });
          content.querySelectorAll('h2,h3,h4').forEach(h => {
            h.id = h.innerText.toLowerCase().replace(/\s+/g, '-');
          });
          hljs.highlightAll();
          resizeKatex();
          runJavascriptLinks();
          // è½½å…¥ dev
          loadDev();
        })
        .catch(() => {
          content.innerHTML = `<p style="color: red;">æœªæ‰¾åˆ° <b>usage_${lang}.md</b> æ–‡ä»¶</p>`;
          loadDev();
        });
    }

    function runJavascriptLinks() {
      const links = document.querySelectorAll('a[href^="info:info"], a[href^="info:info"]');
      links.forEach(link => {
        link.addEventListener('click', function (event) {
          event.preventDefault();
        });
      });
    }

    function resizeKatex() {
      const w = document.querySelector('.markdown-body').clientWidth;
      document.querySelectorAll('.katex-display').forEach(e => {
        e.style.fontSize = '';
        const actual = e.scrollWidth;
        if (actual > w) {
          const fs = parseFloat(getComputedStyle(e).fontSize);
          e.style.fontSize = (fs * w / actual) + 'px';
        }
      });
    }

    function toggleLanguageMenu() {
      const menu = document.getElementById("language-menu");
      menu.style.display = (menu.style.display === "block") ? "none" : "block";
    }
    function changeLanguage(lang) { window.location.search = `?lang=${lang}`; }

    // ===== æ‚¬åœçŠ¶æ€ç®¡ç†ï¼šä¿æŒ dev å†…å¯äº¤äº’ï¼Œç¦»å¼€ä¸¤ç«¯å†éšè— =====
    const hoverState = new Map(); // key -> { hoverLink: bool, hoverDev: bool, el: HTMLElement, timer: number|null }
    const HIDE_DELAY_MS = 120;

    function ensureState(key) {
      if (!hoverState.has(key)) {
        hoverState.set(key, { hoverLink: false, hoverDev: false, el: null, timer: null });
      }
      return hoverState.get(key);
    }

    function scheduleHide(key) {
      const state = ensureState(key);
      if (state.timer) clearTimeout(state.timer);
      state.timer = setTimeout(() => {
        if (!state.hoverLink && !state.hoverDev && state.el) {
          state.el.classList.remove('visible');
        }
        state.timer = null;
      }, HIDE_DELAY_MS);
    }

    function placeAndShowForLink(aaaElement, linkRect) {
      if (!aaaElement) return;
      // æ˜¾ç¤º
      aaaElement.classList.add('visible');
      // æ”¾åœ¨é“¾æ¥æ­£ä¸‹æ–¹å¹¶æ°´å¹³å±…ä¸­
      const topPosition = linkRect.bottom + window.scrollY;
      let leftPosition = linkRect.left + linkRect.width / 2 + window.scrollX - aaaElement.offsetWidth / 2;

      const screenWidth = window.innerWidth;
      const elementWidth = aaaElement.offsetWidth;
      if (leftPosition + elementWidth > screenWidth) leftPosition = screenWidth - elementWidth;
      else if (leftPosition < 0) leftPosition = 0;

      aaaElement.style.position = 'absolute';
      aaaElement.style.top = `${topPosition}px`;
      aaaElement.style.left = `${leftPosition}px`;
    }

    // ===== ä» chartdev.html ç›´æ¥è½½å…¥å¹¶æŒ‚åˆ° bodyï¼ˆä¿æŒä¸åŸ load.js ä¸€è‡´ï¼‰=====
// ===== ä» chartdev.html ç›´æ¥è½½å…¥å¹¶æŒ‚åˆ° bodyï¼ˆä¿æŒä¸åŸ load.js ä¸€è‡´ï¼‰=====
function loadDev() {
  fetch(`./chartdev.html?${Date.now()}`)
    .then(res => {
      if (!res.ok) throw new Error(`åŠ è½½ chartdev.html å¤±è´¥ï¼š${res.status}`);
      return res.text();
    })
    .then(html => {
      const temp = document.createElement('div');
      temp.innerHTML = html;

      const nodes = temp.querySelectorAll('div[aaa]');
      nodes.forEach(node => {
        const key = node.getAttribute('aaa');
        if (!document.querySelector(`body > div[aaa="${CSS.escape(key)}"]`)) {
          node.style.position = node.style.position || 'absolute';
          document.body.appendChild(node);

          // dev æ‚¬åœç›‘å¬ï¼šè¿›å…¥ dev æ—¶ä¿æŒæ˜¾ç¤ºï¼Œç¦»å¼€ dev æ—¶å¯èƒ½éšè—
          node.addEventListener('mouseenter', () => {
            const k = node.getAttribute('aaa');   // âœ… åŠ¨æ€è¯»å–
            const st = ensureState(k);
            st.el = node;
            st.hoverDev = true;
            node.classList.add('visible');
            if (st.timer) { clearTimeout(st.timer); st.timer = null; }
          });

          node.addEventListener('mouseleave', () => {
            const k = node.getAttribute('aaa');   // âœ… åŠ¨æ€è¯»å–
            const st = ensureState(k);
            st.hoverDev = false;
            scheduleHide(k);
          });
        }
      });
    })
    .catch(err => console.error(err));
}

    // ===== Morph ç›¸å…³ï¼šç‚¹å‡»é“¾æ¥æ—¶é¡ºæ»‘åˆ‡æ¢ =====
    let currentKey = null;             // å½“å‰â€œä¸»â€çª—å£ç»‘å®šçš„ key
    let currentEl = null;              // å½“å‰â€œä¸»â€çª—å£å¼•ç”¨çš„ DOM å…ƒç´ ï¼ˆä¼šè¢«å¤ç”¨ä»¥ç§»åŠ¨/æ¢å†…å®¹ï¼‰
    let isMorphing = false;            // åŠ¨ç”»ä¸­é˜²æŠ–
    const MORPH_SWAP_DELAY = 40;       // è½»å¾®å»¶è¿Ÿä»¥ç¡®ä¿ä½ç½®å…ˆåˆ°å†æ›¿æ¢å†…å®¹

    /**
     * å°†ä¸Šä¸€ä¸ªçª—å£ï¼ˆcurrentElï¼‰ç§»åŠ¨åˆ°æ–°é“¾æ¥ä¸‹æ–¹ï¼Œå¹¶æŠŠå†…å®¹æ›¿æ¢ä¸ºæ–°çª—å£å†…å®¹
     * @param {HTMLElement} targetEl  ç›®æ ‡ key çš„ dev èŠ‚ç‚¹ï¼ˆä¾›å–å†…å®¹ä½¿ç”¨ï¼‰
     * @param {DOMRect} linkRect      æ–°é“¾æ¥çš„ rect
     * @param {String} targetKey      ç›®æ ‡ key
     */
    function morphToTarget(targetEl, linkRect, targetKey) {
      if (!currentEl || !targetEl || currentEl === targetEl) return;

      // 1) å–æ¶ˆè€ key çš„éšè—ã€å®šæ—¶å™¨ï¼Œå¹¶æ ‡è®°å½“å‰å…ƒç´ ä¸ºå¯è§
      if (currentKey) {
        const oldState = ensureState(currentKey);
        if (oldState.timer) { clearTimeout(oldState.timer); oldState.timer = null; }
        oldState.hoverLink = false; // ç‚¹å‡»æ—¶ä¸å¼ºä¾èµ– hover
        oldState.hoverDev = false;
        oldState.el = currentEl;
      }
      currentEl.classList.add('visible');

      // 2) å¹³æ»‘ç§»åŠ¨åˆ°æ–°ä½ç½®
      placeAndShowForLink(currentEl, linkRect);

      // 3) å¾®å»¶è¿Ÿåæ›¿æ¢å†…å®¹ä¸ keyï¼ˆè®©ç”¨æˆ·å…ˆçœ‹åˆ°â€œé£è¿‡å»â€ï¼Œå†å˜æ–‡å­—ï¼‰
      setTimeout(() => {
        // æ›¿æ¢å†…éƒ¨å†…å®¹
        currentEl.innerHTML = targetEl.innerHTML;
        // æ›´æ–° aaa keyï¼ˆåç»­ hover/éšè—ä¾èµ–ï¼‰
        currentEl.setAttribute('aaa', targetKey);

        // éšè—/ç§»é™¤ç›®æ ‡åŸèŠ‚ç‚¹ï¼Œé¿å…é‡å¤ï¼ˆä¿ç•™åœ¨ DOM ä½†ä¸å¯è§å³å¯ï¼‰
        targetEl.classList.remove('visible');
        targetEl.style.top = '-99999px';
        targetEl.style.left = '-99999px';

        // æ›´æ–° currentKey & çŠ¶æ€
        currentKey = targetKey;
        const newState = ensureState(currentKey);
        newState.el = currentEl;
        newState.hoverLink = false;
        newState.hoverDev = false;

        isMorphing = false;
      }, MORPH_SWAP_DELAY);
    }

    /**
     * ä»¥â€œå½“å‰å…ƒç´ ä¼˜å…ˆâ€çš„ç­–ç•¥æ˜¾ç¤ºç›®æ ‡çª—å£ï¼š
     * - è‹¥å·²æœ‰ currentElï¼šå°†å…¶ç§»åŠ¨å¹¶æ›¿æ¢ä¸ºç›®æ ‡å†…å®¹ï¼ˆmorphï¼‰
     * - å¦åˆ™æ­£å¸¸æ˜¾ç¤ºç›®æ ‡å…ƒç´ æœ¬èº«
     */
    function showByMorphOrDirect(targetKey, linkRect) {
      const targetEl = document.querySelector(`div[aaa="${targetKey}"]`);
      if (!targetEl) return;

      // å¦‚æœä»æœªæœ‰è¿‡ currentElï¼Œåˆ™ä»¥ targetEl ä¸ºä¸»
      if (!currentEl) {
        currentEl = targetEl;
        currentKey = targetKey;
        const st = ensureState(targetKey);
        st.el = currentEl;
        st.hoverLink = true;
        if (st.timer) { clearTimeout(st.timer); st.timer = null; }
        placeAndShowForLink(currentEl, linkRect);
        return;
      }

      // è‹¥å·²æœ‰ currentEl ä¸” key ä¸åŒï¼Œæ‰§è¡Œ morph
      if (currentEl && currentKey !== targetKey && !isMorphing) {
        isMorphing = true;
        morphToTarget(targetEl, linkRect, targetKey);
        return;
      }

      // key ç›¸åŒæˆ–æ­£åœ¨ morphï¼Œå°±ç›´æ¥æ›´æ–°ä½ç½®å³å¯
      placeAndShowForLink(currentEl, linkRect);
    }

    // ===== ç›‘å¬é¼ æ ‡ç§»åŠ¨åˆ°é“¾æ¥ï¼ˆhoverï¼‰ä¸ç‚¹å‡»ï¼ˆclickï¼‰=====
    function parseInfoKeyFromAnchor(anchor) {
      const url = decodeURIComponent(anchor.href || '');
      const match = url.match(/(info)\(([^)]*)\)/);
      if (!match) return null;
      const params = match[2].split(',').map(param => param.trim().replace(/['"]/g, ''));
      const key = (params.length === 2) ? params.join(',') : params[0];
      return key || null;
    }

    function bindLinkHoverAndClick(target) {
      if (target.dataset.aaaBound) return;
      target.dataset.aaaBound = '1';

      // Hover è¡Œä¸ºï¼šä¸ä¹‹å‰ä¸€è‡´ï¼ˆä½†ä¼šä¼˜å…ˆå¤ç”¨ currentEl ä»¥é¿å…ä¸¤ä¸ªçª—å£é—ªçƒï¼‰
      target.addEventListener('mouseenter', () => {
        const key = parseInfoKeyFromAnchor(target);
        if (!key) return;
        const state = ensureState(key);
        state.hoverLink = true;
        if (state.timer) { clearTimeout(state.timer); state.timer = null; }
        showByMorphOrDirect(key, target.getBoundingClientRect());
      });

      target.addEventListener('mouseleave', () => {
        const key = parseInfoKeyFromAnchor(target);
        if (!key) return;
        const state = ensureState(key);
        state.hoverLink = false;
        scheduleHide(key);
      });

      // ç‚¹å‡»è¡Œä¸ºï¼šè§¦å‘â€œå¹³æ»‘åˆ‡æ¢â€åŠ¨ç”»ï¼ˆmorph ä¼˜å…ˆï¼‰
      target.addEventListener('click', (e) => {
        // åŸæœ¬æˆ‘ä»¬å·²é˜»æ­¢ info:info çš„é»˜è®¤è·³è½¬ï¼›æ­¤å¤„ç¡®ä¿ä¸€æ¬¡
        e.preventDefault();
        const key = parseInfoKeyFromAnchor(target);
        if (!key) return;
        showByMorphOrDirect(key, target.getBoundingClientRect());
      });
    }

    // æ•è·å…¨å±€é¼ æ ‡ç§»åŠ¨ï¼ŒåŠ¨æ€ç»‘å®šé“¾æ¥ï¼ˆä¿æŒä¸åŸæœ‰é€»è¾‘å…¼å®¹ï¼‰
    function checkMouseOnLink(event) {
      const target = event.target;
      if (target.tagName !== 'A') return;
      const key = parseInfoKeyFromAnchor(target);
      if (!key) return;

      // å…ˆç»‘å®š hover/click
      bindLinkHoverAndClick(target);

      // åœ¨ mousemove å‘½ä¸­æ—¶ä¹Ÿåˆ·æ–°ä½ç½®ä¸æ˜¾ç¤ºï¼Œä¿è¯ä½“éªŒé¡ºæ»‘
      const aaaElement = currentEl && currentKey === key
        ? currentEl
        : document.querySelector(`div[aaa="${key}"]`);
      if (!aaaElement) return;

      const state = ensureState(key);
      state.el = currentEl || aaaElement;
      state.hoverLink = true;

      // è‹¥å½“å‰å°±æ˜¯è¿™ä¸ª keyï¼Œç”¨å½“å‰å…ƒç´ å®šä½å³å¯
      placeAndShowForLink(state.el, target.getBoundingClientRect());
    }

    // ===== åˆå§‹åŒ– =====
    window.addEventListener('resize', resizeKatex);
    window.addEventListener('load', loadMarkdown);
    document.addEventListener('mousemove', checkMouseOnLink);
    
    // realityå¯¹ç…§è¡¨å‡½æ•°
    function findScore(constant, target) {
  if (target <= 0) return 600000;
  if (target > constant + 1.5) return "Unable to deduce points";
  
  if (target >= constant) {
    if (target === constant + 1.5) return 1000000;
    return Math.ceil(850000 + (target - constant) * 100000);
  }
  
  if (target >= Math.max(0, 0.5 * constant - 1.5)) {
    const denominator = constant / 300000 + 1 / 100000;
    const score = (target + constant * 11/6 + 8.5) / denominator;
    return Math.min(Math.ceil(score), 849999);
  }
  
  if (Math.abs(constant - 3) < 1e-6) return 600000;
  const score = 600000 + (target * 200000) / (constant - 3);
  return Math.min(Math.ceil(score), 699999);
}

function updateOutput() {
  const input = document.getElementById("constantInput").value;
  const output = document.getElementById("output");
  
  if (input === "") {
    output.textContent = "reality\tscore\nè¯·å¡«å†™ c (constant)ï¼Œç»“æœå°†ä»¥å…¬å¼å½¢å¼è®¡ç®—";
    return;
  }
  
  const c = parseFloat(input);
  let result = "reality\tscore\n";
  
  // å…ˆè®¡ç®—æ‰€æœ‰ç»“æœ
  const data = [];
  for (let r = 0; r <= c + 1.5; r += 0.01) {
    const score = findScore(c, parseFloat(r.toFixed(2)));
    data.push({ r: r.toFixed(2), s: score });
  }
  
  // å€’åºè¾“å‡º
  for (let i = data.length - 1; i >= 0; i--) {
    result += `${data[i].r}\t${data[i].s}\n`;
  }
  
  output.textContent = result;
}
  </script>
</body>
</html>
