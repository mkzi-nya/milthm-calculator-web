<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Usage</title>

  <!-- 资源 -->
  <link rel="stylesheet" href="./github-markdown-dark.min.css">
  <script src="./marked.min.js"></script>
  <script src="./katex.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
  <script src="./index.umd.js"></script>
  <link rel="stylesheet" href="./github-dark.min.css">
  <script src="./highlight.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
      background: #0d1117;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }
    .container { width: 100%; max-width: 900px; }
    .markdown-body { width: 100%; overflow-wrap: break-word; }
    .katex-display {
      display: block !important;
      text-align: center;
      margin: 10px 0;
      font-size: 1em;
    }
    .toc { display: none; }
    pre, code { user-select: text; }

    .language-selector {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #222;
      padding: 5px;
      border-radius: 5px;
      cursor: pointer;
      color: white;
      font-size: 2em;
    }
    .language-menu {
      display: none;
      position: absolute;
      top: 40px;
      right: 10px;
      background: #222;
      border-radius: 5px;
      padding: 10px;
      list-style: none;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }
    .language-menu li {
      padding: 8px 12px;
      cursor: pointer;
      color: white;
    }
    .language-menu li:hover { background: #444; }

    /* dev（aaa）显隐与位移动画 */
    div[aaa] {
      visibility: hidden;
      opacity: 0;
      transition:
        opacity 0.12s ease-in-out,
        visibility 0.12s ease-in-out,
        top 0.12s ease,
        left 0.12s ease;
    }
    div[aaa].visible {
      visibility: visible;
      opacity: 1;
    }
  </style>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-L5K3QVRHFZ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-L5K3QVRHFZ');
  </script>
</head>

<body>
  <!-- 语言选择按钮 -->
  <div class="language-selector" onclick="toggleLanguageMenu()">🌐</div>
  <ul class="language-menu" id="language-menu">
    <li onclick="changeLanguage('zh')">中文</li>
    <li onclick="changeLanguage('zh-tw')">繁體中文</li>
    <li onclick="changeLanguage('en')">English</li>
    <li onclick="changeLanguage('ja')">日本語</li>
    <li onclick="changeLanguage('ko')">한국어</li>
    <li onclick="changeLanguage('ru')">Русский</li>
    <li onclick="changeLanguage('es')">Español</li>
    <li onclick="changeLanguage('vi')">Tiếng Việt</li>
    <li onclick="changeLanguage('ken')">⋿ウᏵ㆑エㄎサ</li>
  </ul>

  <div class="container">
    <article id="content" class="markdown-body"></article>
  </div>

  <script>
    // ===== Markdown & 高亮 & KaTeX =====
    marked.use(markedKatex());
    marked.setOptions({
      highlight: (code, lang) => {
        if (lang && hljs.getLanguage(lang)) return hljs.highlight(code, { language: lang }).value;
        return hljs.highlightAuto(code).value;
      }
    });

    function getUserLanguage() {
      const langMap = {
        "zh": "zh", "zh-cn": "zh", "zh-tw": "zh-tw",
        "en": "en", "ja": "ja", "ko": "ko", "ru": "ru",
        "es": "es", "vi": "vi", "ken": "ken"
      };
      const urlParams = new URLSearchParams(window.location.search);
      let lang = urlParams.get('lang') || navigator.language.toLowerCase();
      return langMap[lang] || "en";
    }

    function loadMarkdown() {
      const lang = getUserLanguage();
      fetch(`./usage_${lang}.md?${Date.now()}`)
        .then(res => res.text())
        .then(md => {
          // 链接处理（保留原逻辑）
          md = md.replace(/\[([^\]]+)\]\(([^)]+)\)/g, function (match, p1, p2) {
            if (p2.startsWith('info:')) {
              const [protocol, rest] = p2.split(':', 2);
              const encodedRest = encodeURIComponent(rest);
              return `[${p1}](${protocol}:${encodedRest})`;
            }
            return `[${p1}](${p2})`;
          });
          content.innerHTML = marked.parse(md, { headerIds: true, mangle: false });
          content.querySelectorAll('h2,h3,h4').forEach(h => {
            h.id = h.innerText.toLowerCase().replace(/\s+/g, '-');
          });
          hljs.highlightAll();
          resizeKatex();
          runJavascriptLinks();
          loadDev();
        })
        .catch(() => {
          content.innerHTML = `<p style="color: red;">未找到 <b>usage_${lang}.md</b> 文件</p>`;
          loadDev();
        });
    }

    function runJavascriptLinks() {
      const links = document.querySelectorAll('a[href^="info:info"], a[href^="info:info"]');
      links.forEach(link => {
        link.addEventListener('click', function (event) { event.preventDefault(); });
      });
    }

    function resizeKatex() {
      const w = document.querySelector('.markdown-body').clientWidth;
      document.querySelectorAll('.katex-display').forEach(e => {
        e.style.fontSize = '';
        const actual = e.scrollWidth;
        if (actual > w) {
          const fs = parseFloat(getComputedStyle(e).fontSize);
          e.style.fontSize = (fs * w / actual) + 'px';
        }
      });
    }

    function toggleLanguageMenu() {
      const menu = document.getElementById("language-menu");
      menu.style.display = (menu.style.display === "block") ? "none" : "block";
    }
    function changeLanguage(lang) { window.location.search = `?lang=${lang}`; }

    // ===== 悬停/点击状态管理 =====
    // hoverLink: 是否在链接上；hoverDev: 是否在 dev 上；
    // byClick: 该 dev 是否由点击打开（影响关闭策略）
    const hoverState = new Map(); // key -> { hoverLink, hoverDev, byClick, el, timer }
    const HIDE_DELAY_MS = 120;

    function ensureState(key) {
      if (!hoverState.has(key)) {
        hoverState.set(key, { hoverLink: false, hoverDev: false, byClick: false, el: null, timer: null });
      }
      return hoverState.get(key);
    }

    function hideNow(key) {
      const st = ensureState(key);
      if (st.timer) { clearTimeout(st.timer); st.timer = null; }
      const el = st.el || document.querySelector(`div[aaa="${CSS.escape(key)}"]`);
      if (el) el.classList.remove('visible');
      // 恢复为“非点击打开”状态
      st.byClick = false;
    }

    function scheduleHide(key) {
      const st = ensureState(key);
      if (st.timer) clearTimeout(st.timer);
      st.timer = setTimeout(() => {
        if (!st.hoverLink && !st.hoverDev && st.el) {
          st.el.classList.remove('visible');
          st.byClick = false;
        }
        st.timer = null;
      }, HIDE_DELAY_MS);
    }

    function placeAndShowForLink(aaaElement, linkRect) {
      if (!aaaElement) return;
      aaaElement.classList.add('visible');
      const topPosition = linkRect.bottom + window.scrollY;
      let leftPosition = linkRect.left + linkRect.width / 2 + window.scrollX - aaaElement.offsetWidth / 2;

      const screenWidth = window.innerWidth;
      const elementWidth = aaaElement.offsetWidth;
      if (leftPosition + elementWidth > screenWidth) leftPosition = screenWidth - elementWidth;
      else if (leftPosition < 0) leftPosition = 0;

      aaaElement.style.position = 'absolute';
      aaaElement.style.top = `${topPosition}px`;
      aaaElement.style.left = `${leftPosition}px`;
    }

    // ===== 从 chartdev.html 载入，并把所有 div[aaa] 挂到 body =====
    function loadDev() {
      fetch(`./chartdev.html?${Date.now()}`)
        .then(res => {
          if (!res.ok) throw new Error(`加载 chartdev.html 失败：${res.status}`);
          return res.text();
        })
        .then(html => {
          const temp = document.createElement('div');
          temp.innerHTML = html;

          const nodes = temp.querySelectorAll('div[aaa]');
          nodes.forEach(node => {
            const key = node.getAttribute('aaa');
            if (!document.querySelector(`body > div[aaa="${CSS.escape(key)}"]`)) {
              node.style.position = node.style.position || 'absolute';
              document.body.appendChild(node);

              // dev 悬停监听
              node.addEventListener('mouseenter', () => {
                const k = node.getAttribute('aaa');   // 动态读取（morph 后也正确）
                const st = ensureState(k);
                st.el = node;
                st.hoverDev = true;
                // 只有“点击打开”的 dev 才允许在 dev 上保持显示与交互
                if (st.byClick) {
                  node.classList.add('visible');
                  if (st.timer) { clearTimeout(st.timer); st.timer = null; }
                }
              });

              node.addEventListener('mouseleave', () => {
                const k = node.getAttribute('aaa');
                const st = ensureState(k);
                st.hoverDev = false;
                // 若由点击打开：离开 dev 且不在链接上才隐藏
                if (st.byClick) scheduleHide(k);
                // 若由 hover 打开：应已在离开链接时立即关闭，这里无需额外处理
              });
            }
          });
        })
        .catch(err => console.error(err));
    }

    // ===== Morph：点击链接时平滑切换 =====
    let currentKey = null;
    let currentEl = null;
    let isMorphing = false;
    const MORPH_SWAP_DELAY = 40;

    function morphToTarget(targetEl, linkRect, targetKey, byClick) {
      if (!currentEl || !targetEl || currentEl === targetEl) return;

      if (currentKey) {
        const oldState = ensureState(currentKey);
        if (oldState.timer) { clearTimeout(oldState.timer); oldState.timer = null; }
        oldState.hoverLink = false;
        oldState.hoverDev = false;
        oldState.el = currentEl;
      }
      currentEl.classList.add('visible');
      placeAndShowForLink(currentEl, linkRect);

      setTimeout(() => {
        // 替换内容与 key
        currentEl.innerHTML = targetEl.innerHTML;
        currentEl.setAttribute('aaa', targetKey);

        // 隐藏目标原节点
        targetEl.classList.remove('visible');
        targetEl.style.top = '-99999px';
        targetEl.style.left = '-99999px';

        // 更新状态到新 key
        currentKey = targetKey;
        const newState = ensureState(currentKey);
        newState.el = currentEl;
        newState.hoverLink = false;
        newState.hoverDev = false;
        newState.byClick = !!byClick;

        isMorphing = false;
      }, MORPH_SWAP_DELAY);
    }

    function showByMorphOrDirect(targetKey, linkRect, byClick) {
      const targetEl = document.querySelector(`div[aaa="${targetKey}"]`);
      if (!targetEl) return;

      if (!currentEl) {
        currentEl = targetEl;
        currentKey = targetKey;
        const st = ensureState(targetKey);
        st.el = currentEl;
        st.hoverLink = true;
        st.byClick = !!byClick;
        if (st.timer) { clearTimeout(st.timer); st.timer = null; }
        placeAndShowForLink(currentEl, linkRect);
        return;
      }

      if (currentEl && currentKey !== targetKey && !isMorphing) {
        isMorphing = true;
        morphToTarget(targetEl, linkRect, targetKey, byClick);
        return;
      }

      // 相同 key：仅更新位置；更新 byClick（可能从 hover 变为 click）
      const st = ensureState(targetKey);
      st.byClick = st.byClick || !!byClick;
      placeAndShowForLink(currentEl, linkRect);
    }

    // ===== 解析 info(...) key =====
    function parseInfoKeyFromAnchor(anchor) {
      const url = decodeURIComponent(anchor.href || '');
      const match = url.match(/(info)\(([^)]*)\)/);
      if (!match) return null;
      const params = match[2].split(',').map(param => param.trim().replace(/['"]/g, ''));
      const key = (params.length === 2) ? params.join(',') : params[0];
      return key || null;
    }

    // ===== 绑定链接的 hover / click 行为 =====
    function bindLinkHoverAndClick(target) {
      if (target.dataset.aaaBound) return;
      target.dataset.aaaBound = '1';

      // Hover：仅“悬停打开”——移开链接即关闭（不管是否进入 dev）
      target.addEventListener('mouseenter', () => {
        const key = parseInfoKeyFromAnchor(target);
        if (!key) return;
        const st = ensureState(key);
        st.hoverLink = true;
        st.byClick = false; // 悬停模式
        if (st.timer) { clearTimeout(st.timer); st.timer = null; }
        showByMorphOrDirect(key, target.getBoundingClientRect(), false);
      });

      target.addEventListener('mouseleave', () => {
        const key = parseInfoKeyFromAnchor(target);
        if (!key) return;
        const st = ensureState(key);
        st.hoverLink = false;

        if (!st.byClick) {
          // 悬停打开：离开链接立即关闭（即使鼠标移到 dev 上也关闭）
          hideNow(key);
        } else {
          // 点击打开：离开链接不立即关闭，等待离开 dev 再关闭
          scheduleHide(key);
        }
      });

      // Click：点击打开或切换为“点击模式”——移到 dev 上不关闭，离开 dev 才关闭
      target.addEventListener('click', (e) => {
        e.preventDefault(); // 防止 info:info 导航
        const key = parseInfoKeyFromAnchor(target);
        if (!key) return;
        const st = ensureState(key);
        st.byClick = true;  // 点击模式
        st.hoverLink = true;
        if (st.timer) { clearTimeout(st.timer); st.timer = null; }
        showByMorphOrDirect(key, target.getBoundingClientRect(), true);
      });
    }

    // ===== 全局鼠标移动：用于顺滑跟随定位，同时动态绑定链接 =====
    function checkMouseOnLink(event) {
      const target = event.target;
      if (target.tagName !== 'A') return;
      const key = parseInfoKeyFromAnchor(target);
      if (!key) return;

      bindLinkHoverAndClick(target);

      // 跟随移动（不改变 byClick 状态）
      const el = (currentEl && currentKey === key) ? currentEl : document.querySelector(`div[aaa="${key}"]`);
      if (!el) return;
      const st = ensureState(key);
      st.el = currentEl || el;
      st.hoverLink = true;
      placeAndShowForLink(st.el, target.getBoundingClientRect());
    }

    // ===== 初始化 =====
    window.addEventListener('resize', resizeKatex);
    window.addEventListener('load', loadMarkdown);
    document.addEventListener('mousemove', checkMouseOnLink);
  </script>
</body>
</html>
