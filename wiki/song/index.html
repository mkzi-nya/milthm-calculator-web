<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>曲目信息</title>
  <link rel="stylesheet" href="../github-markdown-dark.min.css">
  <script src="../marked.min.js"></script>
  <script src="../katex.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
  <script src="../index.umd.js"></script>
  <link rel="stylesheet" href="../github-dark.min.css">
  <script src="../highlight.min.js"></script>
  <script type="module">
    import { songMap } from './map.js';
    window.songMap = songMap;
  </script>

  <style>
    body {
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
      background: #0d1117;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }
    .container { width: 100%; max-width: 900px; }
    .markdown-body { width: 100%; overflow-wrap: break-word; }
    .katex-display {
      display: block !important;
      text-align: center;
      margin: 10px 0;
      font-size: 1em;
    }
    .toc { display: none; }
    pre, code { user-select: text; }

    /* 默认隐藏 dev（aaa）并平滑显隐；增加 top/left 过渡用于移动动画 */
    div[aaa] {
      visibility: hidden;
      opacity: 0;
      transition:
        opacity 0.12s ease-in-out,
        visibility 0.12s ease-in-out,
        top 0.12s ease,
        left 0.12s ease;
    }
    div[aaa].visible {
      visibility: visible;
      opacity: 1;
    }

    /* 相似度匹配结果样式 */
    .similarity-results {
      margin-top: 20px;
      padding: 15px;
      border: 1px solid #30363d;
      border-radius: 6px;
      background-color: #161b22;
    }
    .similarity-results h2 {
      margin-top: 0;
      color: #f0f6fc;
    }
    .similarity-results ul {
      padding-left: 20px;
    }
    .similarity-results li {
      margin-bottom: 8px;
    }
    .similarity-results a {
      color: #58a6ff;
      text-decoration: none;
    }
    .similarity-results a:hover {
      text-decoration: underline;
    }
  </style>

<body>
  <div class="container">
    <article id="content" class="markdown-body"></article>
  </div>

  <!-- 内联 Markdown：直接整体替换 # 所有曲目

- [Aconsma](./?q=Aconsma)
- [Agnostic](./?q=Agnostic)
- [Aleph-0](./?q=Aleph-0)
- [Algebra](./?q=Algebra)
- [Autumn Rain](./?q=Autumn_Rain)
- [BUCHiAGE Fireworks](./?q=BUCHiAGE_Fireworks)
- [Before it Ends](./?q=Before_it_Ends)
- [Bio-Engineering](./?q=Bio-Engineering)
- [Brightened Demonios](./?q=Brightened_Demonios)
- [Broken Conviction](./?q=Broken_Conviction)
- [Chartreuse Green](./?q=Chartreuse_Green)
- [Contrasty Angeles](./?q=Contrasty_Angeles)
- [Curse of 14](./?q=Curse_of_14)
- [Deluge](./?q=Deluge)
- [Dogbite](./?q=Dogbite)
- [Dum! Dum!! Dum!!!](./?q=Dum_Dum_Dum)
- [Elsorhg](./?q=Elsorhg)
- [FULi AUTO SHOOTER](./?q=FULi_AUTO_SHOOTER)
- [Fantasia Sonata Arcadia](./?q=Fantasia_Sonata_Arcadia)
- [Fantasia Sonata Botanical Garden](./?q=Fantasia_Sonata_Botanical_Garden)
- [Fantasia Sonata God Dance](./?q=Fantasia_Sonata_God_Dance)
- [Fantasia Sonata Hope](./?q=Fantasia_Sonata_Hope)
- [Fantasia Sonata Reflection](./?q=Fantasia_Sonata_Reflection)
- [Fantasia Sonata Sky Syndrome](./?q=Fantasia_Sonata_Sky_Syndrome)
- [Fantasia Sonata Stars](./?q=Fantasia_Sonata_Stars)
- [Fluorescent Light](./?q=Fluorescent_Light)
- [Fly To Meteor (Milthm Edit)](./?q=Fly_To_Meteor_Milthm_Edit)
- [Fly To Meteor feat.兔柒 (Milthm Edit)](./?q=Fly_To_Meteor_featTuQi_Milthm_Edit)
- [Fragment of Memories](./?q=Fragment_of_Memories)
- [Future Unbound (Game Edit)](./?q=Future_Unbound_Game_Edit)
- [Garden](./?q=Garden)
- [GlassyHeart.](./?q=GlassyHeart)
- [HYPER MEMORIES](./?q=HYPER_MEMORIES)
- [Hikari](./?q=Hikari)
- [IN](./?q=IN)
- [INFP.mp3](./?q=INFPmp3)
- [Innocent white](./?q=Innocent_white)
- [Jump out?](./?q=Jump_out)
- [KASANE](./?q=KASANE)
- [Kayava](./?q=Kayava)
- [LOUDER!](./?q=LOUDER)
- [Meltovt Necrosys](./?q=Meltovt_Necrosys)
- [Moonflutter](./?q=Moonflutter)
- [Moving On](./?q=Moving_On)
- [Myth compiler](./?q=Myth_compiler)
- [Oiiaioooooiai](./?q=Oiiaioooooiai)
- [Oniichan](./?q=Oniichan)
- [OverRain](./?q=OverRain)
- [Psyched Fevereiro](./?q=Psyched_Fevereiro)
- [Pthahnil](./?q=Pthahnil)
- [Rainbow Flavor!](./?q=Rainbow_Flavor)
- [Regnaissance](./?q=Regnaissance)
- [Sakuyahime](./?q=Sakuyahime)
- [Sheer Ice Torrent](./?q=Sheer_Ice_Torrent)
- [Sound of Nature](./?q=Sound_of_Nature)
- [Splash the Beat!!](./?q=Splash_the_Beat)
- [Sundown](./?q=Sundown)
- [Threat - Metropolis](./?q=Threat_-_Metropolis)
- [Threat - Sky Islands](./?q=Threat_-_Sky_Islands)
- [Threat - Superstructure](./?q=Threat_-_Superstructure)
- [Threat - Waterfront Complex](./?q=Threat_-_Waterfront_Complex)
- [Vestige of Dreams](./?q=Vestige_of_Dreams)
- [Virtual S0da](./?q=Virtual_S0da)
- [WATER](./?q=WATER)
- [Welcome to Milthm](./?q=Welcome_to_Milthm)
- [White Lizard](./?q=White_Lizard)
- [Words](./?q=Words)
- [apOapSis(Edit)](./?q=apOapSisEdit)
- [cafe in 6412I731V](./?q=cafe_in_6412I731V)
- [conflict](./?q=conflict)
- [cybernetic blazar](./?q=cybernetic_blazar)
- [slic.hertz #GdbG](./?q=slichertz_GdbG)
- [いつか忘れるんだろう](./?q=Someday_I_will_Forget)
- [はんてん](./?q=Hanten)
- [イコラト](./?q=eclat)
- [サイクルの欠片](./?q=Pieces_of_the_Cycle)
- [ニニ (feat. Qayo & mii)](./?q=Nini_feat_Qayo__mii)
- [ネオン色のまち feat. Mai](./?q=Neon_Iro_no_Machi_feat_Mai)
- [ホシフルヨルニ](./?q=Hoshifuru_Yoruni)
- [仮想明日](./?q=Imaginary_Tomorrow)
- [参宿四\~Betelgeuse\~](./?q=Betelgeuse)
- [命日](./?q=Meinichi)
- [夜風](./?q=Yokaze)
- [大月墜落狂想](./?q=Moonfall)
- [时落之雨](./?q=Episodic_Rain)
- [暮予星光](./?q=Reminiscence_in_Starlight)
- [樱落繁花](./?q=A_Reincarnation_of_a_Scattering_Spring)
- [灯ノ桜蝶](./?q=Akashinosakuracho)
- [烁雨](./?q=Sparkrain)
- [白虎蓮華](./?q=Tiger_Lotus)
- [百九十](./?q=190)
- [粗线条的雨](./?q=Thick_Rain)
- [花月](./?q=Kagetsu)
- [運命](./?q=Unmei)
- [雨之城](./?q=Castle_in_the_Rain)
- [雨女](./?q=Ameonna)
- [靈](./?q=Rei)
- [驟雨の狭間](./?q=Rainshower)
- [☹](./?q=Blueface)

# 章节目录
- [序章: 雨的声音](./?q=rainfall_sounds)
- [主线章节一: 甜与苦的一体两面](./?q=two_sides_of_bitter_and_sweet)
- [支线章节一: 花裳随雨得春迟](./?q=a_spring_waiting_in_blossoms)
- [联动: 雨世界](./?q=rain_world)
- [联动: Notanote](./?q=notanote)

 -->
  <script type="text/markdown" id="md">
# 所有曲目

- [Aconsma](./?q=Aconsma)
- [Agnostic](./?q=Agnostic)
- [Aleph-0](./?q=Aleph-0)
- [Algebra](./?q=Algebra)
- [Autumn Rain](./?q=Autumn_Rain)
- [BUCHiAGE Fireworks](./?q=BUCHiAGE_Fireworks)
- [Before it Ends](./?q=Before_it_Ends)
- [Bio-Engineering](./?q=Bio-Engineering)
- [Brightened Demonios](./?q=Brightened_Demonios)
- [Broken Conviction](./?q=Broken_Conviction)
- [Chartreuse Green](./?q=Chartreuse_Green)
- [Contrasty Angeles](./?q=Contrasty_Angeles)
- [Curse of 14](./?q=Curse_of_14)
- [Deluge](./?q=Deluge)
- [Dogbite](./?q=Dogbite)
- [Dum! Dum!! Dum!!!](./?q=Dum_Dum_Dum)
- [Elsorhg](./?q=Elsorhg)
- [FULi AUTO SHOOTER](./?q=FULi_AUTO_SHOOTER)
- [Fantasia Sonata Arcadia](./?q=Fantasia_Sonata_Arcadia)
- [Fantasia Sonata Botanical Garden](./?q=Fantasia_Sonata_Botanical_Garden)
- [Fantasia Sonata God Dance](./?q=Fantasia_Sonata_God_Dance)
- [Fantasia Sonata Hope](./?q=Fantasia_Sonata_Hope)
- [Fantasia Sonata Reflection](./?q=Fantasia_Sonata_Reflection)
- [Fantasia Sonata Sky Syndrome](./?q=Fantasia_Sonata_Sky_Syndrome)
- [Fantasia Sonata Stars](./?q=Fantasia_Sonata_Stars)
- [Fluorescent Light](./?q=Fluorescent_Light)
- [Fly To Meteor (Milthm Edit)](./?q=Fly_To_Meteor_Milthm_Edit)
- [Fly To Meteor feat.兔柒 (Milthm Edit)](./?q=Fly_To_Meteor_featTuQi_Milthm_Edit)
- [Fragment of Memories](./?q=Fragment_of_Memories)
- [Future Unbound (Game Edit)](./?q=Future_Unbound_Game_Edit)
- [Garden](./?q=Garden)
- [GlassyHeart.](./?q=GlassyHeart)
- [HYPER MEMORIES](./?q=HYPER_MEMORIES)
- [Hikari](./?q=Hikari)
- [IN](./?q=IN)
- [INFP.mp3](./?q=INFPmp3)
- [Innocent white](./?q=Innocent_white)
- [Jump out?](./?q=Jump_out)
- [KASANE](./?q=KASANE)
- [Kayava](./?q=Kayava)
- [LOUDER!](./?q=LOUDER)
- [Meltovt Necrosys](./?q=Meltovt_Necrosys)
- [Moonflutter](./?q=Moonflutter)
- [Moving On](./?q=Moving_On)
- [Myth compiler](./?q=Myth_compiler)
- [Oiiaioooooiai](./?q=Oiiaioooooiai)
- [Oniichan](./?q=Oniichan)
- [OverRain](./?q=OverRain)
- [Psyched Fevereiro](./?q=Psyched_Fevereiro)
- [Pthahnil](./?q=Pthahnil)
- [Rainbow Flavor!](./?q=Rainbow_Flavor)
- [Regnaissance](./?q=Regnaissance)
- [Sakuyahime](./?q=Sakuyahime)
- [Sheer Ice Torrent](./?q=Sheer_Ice_Torrent)
- [Sound of Nature](./?q=Sound_of_Nature)
- [Splash the Beat!!](./?q=Splash_the_Beat)
- [Sundown](./?q=Sundown)
- [Threat - Metropolis](./?q=Threat_-_Metropolis)
- [Threat - Sky Islands](./?q=Threat_-_Sky_Islands)
- [Threat - Superstructure](./?q=Threat_-_Superstructure)
- [Threat - Waterfront Complex](./?q=Threat_-_Waterfront_Complex)
- [Vestige of Dreams](./?q=Vestige_of_Dreams)
- [Virtual S0da](./?q=Virtual_S0da)
- [WATER](./?q=WATER)
- [Welcome to Milthm](./?q=Welcome_to_Milthm)
- [White Lizard](./?q=White_Lizard)
- [Words](./?q=Words)
- [apOapSis(Edit)](./?q=apOapSisEdit)
- [cafe in 6412I731V](./?q=cafe_in_6412I731V)
- [conflict](./?q=conflict)
- [cybernetic blazar](./?q=cybernetic_blazar)
- [slic.hertz #GdbG](./?q=slichertz_GdbG)
- [いつか忘れるんだろう](./?q=Someday_I_will_Forget)
- [はんてん](./?q=Hanten)
- [イコラト](./?q=eclat)
- [サイクルの欠片](./?q=Pieces_of_the_Cycle)
- [ニニ (feat. Qayo & mii)](./?q=Nini_feat_Qayo__mii)
- [ネオン色のまち feat. Mai](./?q=Neon_Iro_no_Machi_feat_Mai)
- [ホシフルヨルニ](./?q=Hoshifuru_Yoruni)
- [仮想明日](./?q=Imaginary_Tomorrow)
- [参宿四\~Betelgeuse\~](./?q=Betelgeuse)
- [命日](./?q=Meinichi)
- [夜風](./?q=Yokaze)
- [大月墜落狂想](./?q=Moonfall)
- [时落之雨](./?q=Episodic_Rain)
- [暮予星光](./?q=Reminiscence_in_Starlight)
- [樱落繁花](./?q=A_Reincarnation_of_a_Scattering_Spring)
- [灯ノ桜蝶](./?q=Akashinosakuracho)
- [烁雨](./?q=Sparkrain)
- [白虎蓮華](./?q=Tiger_Lotus)
- [百九十](./?q=190)
- [粗线条的雨](./?q=Thick_Rain)
- [花月](./?q=Kagetsu)
- [運命](./?q=Unmei)
- [雨之城](./?q=Castle_in_the_Rain)
- [雨女](./?q=Ameonna)
- [靈](./?q=Rei)
- [驟雨の狭間](./?q=Rainshower)
- [☹](./?q=Blueface)

# 章节目录
- [序章: 雨的声音](./?q=rainfall_sounds)
- [主线章节一: 甜与苦的一体两面](./?q=two_sides_of_bitter_and_sweet)
- [支线章节一: 花裳随雨得春迟](./?q=a_spring_waiting_in_blossoms)
- [联动: 雨世界](./?q=rain_world)
- [联动: Notanote](./?q=notanote)


  </script>

  <script>
    // 相似度计算函数
    function calculateSimilarity(str1, str2) {
      const s1 = str1.toLowerCase();
      const s2 = str2.toLowerCase();
      
      if (s1 === s2) return 100;
      
      // 计算编辑距离
      const track = Array(s2.length + 1).fill(null).map(() =>
        Array(s1.length + 1).fill(null));
      for (let i = 0; i <= s1.length; i += 1) {
        track[0][i] = i;
      }
      for (let j = 0; j <= s2.length; j += 1) {
        track[j][0] = j;
      }
      for (let j = 1; j <= s2.length; j += 1) {
        for (let i = 1; i <= s1.length; i += 1) {
          const indicator = s1[i - 1] === s2[j - 1] ? 0 : 1;
          track[j][i] = Math.min(
            track[j][i - 1] + 1,
            track[j - 1][i] + 1,
            track[j - 1][i - 1] + indicator
          );
        }
      }
      
      const distance = track[s2.length][s1.length];
      const maxLength = Math.max(s1.length, s2.length);
      return Math.round((1 - distance / maxLength) * 100);
    }

    // 从路径或查询参数中提取搜索词
    function extractSearchTerm() {
      const pathname = window.location.pathname;
      const urlParams = new URLSearchParams(window.location.search);
      const hash = window.location.hash.substring(1);
      
      // 1. 先检查路径中的直接访问（如 /百九十, /190）
      const pathParts = pathname.split('/');
      const lastPathPart = pathParts[pathParts.length - 1];
      
      // 去除可能的扩展名
      const cleanPathPart = lastPathPart.replace(/\.(html|htm|md|txt)$/i, '');
      
      // 如果路径不是 index.html 或空，且不是已知资源文件
      if (cleanPathPart && 
          cleanPathPart !== 'index' && 
          cleanPathPart !== '' &&
          !cleanPathPart.includes('.css') &&
          !cleanPathPart.includes('.js') &&
          !cleanPathPart.includes('.png') &&
          !cleanPathPart.includes('.jpg') &&
          !cleanPathPart.includes('.ico')) {
        return decodeURIComponent(cleanPathPart);
      }
      
      // 2. 检查查询参数（支持多种格式）
      // 支持 ?q=..., ?1=..., ?search=... 等多种参数名
      for (const [key, value] of urlParams.entries()) {
        if (value && (key === 'q' || key === 'search' || /^\d+$/.test(key))) {
          return decodeURIComponent(value);
        }
      }
      
      // 3. 检查 ?百九十 这种格式（没有参数名）
      const searchString = window.location.search.substring(1);
      if (searchString && !searchString.includes('=')) {
        return decodeURIComponent(searchString);
      }
      
      // 4. 检查hash
      if (hash) {
        return decodeURIComponent(hash);
      }
      
      return null;
    }

    // 查找最佳匹配的拉丁名
    function findBestLatinName(searchTerm) {
      if (!window.songMap) return null;
      
      // 1. 直接匹配拉丁名
      if (window.songMap[searchTerm]) {
        return searchTerm;
      }
      
      // 2. 直接匹配数字键
      if (/^\d+$/.test(searchTerm) && window.songMap[searchTerm]) {
        return searchTerm;
      }
      
      // 3. 匹配中文名
      for (const [latinName, data] of Object.entries(window.songMap)) {
        const chineseName = data[0];
        if (chineseName === searchTerm) {
          return latinName;
        }
      }
      
      return null;
    }

    // 查找相似度匹配结果
    function findSimilarityMatches(searchTerm) {
      if (!window.songMap) return [];
      
      const results = [];
      
      // 遍历所有曲目进行相似度匹配
      for (const [latinName, data] of Object.entries(window.songMap)) {
        const chineseName = data[0];
        const similarity1 = calculateSimilarity(searchTerm, latinName);
        const similarity2 = calculateSimilarity(searchTerm, chineseName);
        const similarity3 = /^\d+$/.test(searchTerm) ? calculateSimilarity(searchTerm, latinName) : 0;
        const maxSimilarity = Math.max(similarity1, similarity2, similarity3);
        
        if (maxSimilarity >= 35) {
          results.push({
            latinName,
            chineseName,
            similarity: maxSimilarity
          });
        }
      }
      
      // 按相似度排序
      results.sort((a, b) => b.similarity - a.similarity);
      
      return results;
    }

    // 检查是否应该重定向到100%匹配
    function shouldRedirectToExactMatch(searchTerm, results) {
      // 检查是否有100%匹配的（只有大小写不同）
      const exactMatch = results.find(r => r.similarity === 100);
      if (exactMatch) {
        // 防止重复跳转：检查当前URL是否已经是对应的路径
        const currentPath = window.location.pathname;
        const expectedPath = `/${exactMatch.latinName}`;
        
        // 如果当前路径不是预期的路径，则重定向
        if (!currentPath.endsWith(expectedPath) && 
            !currentPath.endsWith(`${expectedPath}/`) &&
            !window.location.search.includes(`?q=${encodeURIComponent(exactMatch.latinName)}`) &&
            !window.location.search.includes(`?${encodeURIComponent(exactMatch.latinName)}`)) {
          
          // 使用history.replaceState更新URL，不添加历史记录
          const newUrl = `/${encodeURIComponent(exactMatch.latinName)}`;
          window.history.replaceState(null, '', newUrl);
          return true;
        }
      }
      return false;
    }

    // 加载Markdown内容
    async function loadMarkdown() {
      const searchTerm = extractSearchTerm();
      const pathname = window.location.pathname;
      
      // 检查是否应该显示404
      const shouldShow404 = !pathname.endsWith('index.html') && 
                           !pathname.endsWith('/') && 
                           !searchTerm && 
                           pathname !== '/' && 
                           !pathname.includes('.') &&
                           window.location.search === '';
      
      if (shouldShow404) {
        // 加载404页面
        try {
          const response = await fetch('./404.html');
          if (response.ok) {
            const html = await response.text();
            document.documentElement.innerHTML = html;
            return;
          }
        } catch (error) {
          console.error('加载404页面失败:', error);
        }
      }
      
      let mdContent = document.getElementById('md').textContent.replace(/^\n/, '');
      
      // 如果有搜索词，尝试加载对应的md文件
      if (searchTerm) {
        try {
          // 查找精确匹配的拉丁名
          const exactLatinName = findBestLatinName(searchTerm);
          
          if (exactLatinName) {
            // 找到精确匹配，加载对应的md文件
            const response = await fetch(`./${exactLatinName}.md`);
            if (response.ok) {
              mdContent = await response.text();
            } else {
              // 如果文件加载失败，查找相似度匹配
              const similarityResults = findSimilarityMatches(searchTerm);
              
              // 检查是否需要重定向到100%匹配
              if (shouldRedirectToExactMatch(searchTerm, similarityResults)) {
                // 重新加载页面
                window.location.reload();
                return;
              }
              
              // 显示相似度匹配结果
              mdContent = await buildSimilarityResultsContent(searchTerm, similarityResults, true);
            }
          } else {
            // 没有精确匹配，查找相似度匹配
            const similarityResults = findSimilarityMatches(searchTerm);
            
            // 检查是否需要重定向到100%匹配
            if (shouldRedirectToExactMatch(searchTerm, similarityResults)) {
              // 重新加载页面
              window.location.reload();
              return;
            }
            
            if (similarityResults.length === 0) {
              // 没有相似度在50%以上的，返回默认内容
              mdContent = document.getElementById('md').textContent.replace(/^\n/, '');
            } else {
              // 显示相似度匹配结果
              mdContent = await buildSimilarityResultsContent(searchTerm, similarityResults, false);
            }
          }
        } catch (error) {
          console.error('加载md文件失败:', error);
          const similarityResults = findSimilarityMatches(searchTerm);
          mdContent = await buildSimilarityResultsContent(searchTerm, similarityResults, false);
        }
      }
      
      // 链接自动转义处理（原逻辑保留）
      mdContent = mdContent.replace(/\[([^\]]+)\]\(([^)]+)\)/g, function (match, p1, p2) {
        if (p2.startsWith('info:')) {
          const [protocol, rest] = p2.split(':', 2);
          const encodedRest = encodeURIComponent(rest);
          return `[${p1}](${protocol}:${encodedRest})`;
        }
        return match;
      });

      content.innerHTML = marked.parse(mdContent, { headerIds: true, mangle: false });
      content.querySelectorAll('h2,h3,h4').forEach(h => {
        h.id = h.innerText.toLowerCase().replace(/\s+/g, '-');
      });
      hljs.highlightAll();
      resizeKatex();
      runJavascriptLinks();
      loadDev();
    }

    // 构建相似度匹配结果内容
    async function buildSimilarityResultsContent(searchTerm, results, hasExactMatch) {
      if (results.length === 0) {
        if (hasExactMatch) {
          // 有精确匹配但文件不存在
          return `# 曲目文件未找到\n\n**${searchTerm}** 对应的文件不存在。\n\n可能的原因：\n1. Markdown文件尚未创建\n2. 文件名称拼写错误\n3. 文件被移动或删除`;
        } else {
          return "# 未找到对应曲目\n\n没有找到与您的搜索匹配的曲目。";
        }
      }
      
      // 构建相似度匹配结果
      let md = hasExactMatch 
        ? `# 曲目文件未找到\n\n**${searchTerm}** 对应的文件不存在，但找到以下相似曲目：\n\n`
        : `# 未找到对应曲目\n## 您想查找的可能是\n\n`;
      
      // 只显示前5个最相似的结果
      const topResults = results.slice(0, 5);
      topResults.forEach(result => {
        // 多种访问方式
        md += `- [${result.chineseName}](./?q=${encodeURIComponent(result.latinName)})\n`;
      });
      
      md += `\n> 搜索词: "${searchTerm}"\n`;
      return md;
    }

    // 拦截链接点击，处理多种访问方式
    function interceptLinkClicks() {
      document.addEventListener('click', function(e) {
        if (e.target.tagName === 'A') {
          const href = e.target.getAttribute('href');
          
          // 如果是相对路径且不是以 . 开头，也不是 http/https 开头
          if (href && 
              !href.startsWith('http') && 
              !href.startsWith('#') && 
              !href.startsWith('info:') &&
              !href.includes('.css') &&
              !href.includes('.js') &&
              !href.includes('.html') &&
              !href.includes('.md') &&
              !href.startsWith('.')) {
            
            e.preventDefault();
            
            // 检查是否是字典内的内容
            const searchTerm = decodeURIComponent(href);
            const bestLatinName = findBestLatinName(searchTerm);
            
            if (bestLatinName) {
              // 重定向到路径方式（/拉丁名）
              window.location.href = `/${encodeURIComponent(bestLatinName)}`;
            } else {
              // 直接使用当前路径方式
              window.location.href = href;
            }
          }
        }
      });
    }

    function runJavascriptLinks() {
      const links = document.querySelectorAll('a[href^="info:info"], a[href^="info:info"]');
      links.forEach(link => {
        link.addEventListener('click', function (event) {
          event.preventDefault();
        });
      });
      
      // 拦截普通链接点击
      interceptLinkClicks();
    }

    function resizeKatex() {
      const w = document.querySelector('.markdown-body').clientWidth;
      document.querySelectorAll('.katex-display').forEach(e => {
        e.style.fontSize = '';
        const actual = e.scrollWidth;
        if (actual > w) {
          const fs = parseFloat(getComputedStyle(e).fontSize);
          e.style.fontSize = (fs * w / actual) + 'px';
        }
      });
    }

    // ===== 悬停状态管理：保持 dev 内可交互，离开两端再隐藏 =====
    const hoverState = new Map(); // key -> { hoverLink: bool, hoverDev: bool, el: HTMLElement, timer: number|null }
    const HIDE_DELAY_MS = 120;

    function ensureState(key) {
      if (!hoverState.has(key)) {
        hoverState.set(key, { hoverLink: false, hoverDev: false, el: null, timer: null });
      }
      return hoverState.get(key);
    }

    function scheduleHide(key) {
      const state = ensureState(key);
      if (state.timer) clearTimeout(state.timer);
      state.timer = setTimeout(() => {
        if (!state.hoverLink && !state.hoverDev && state.el) {
          state.el.classList.remove('visible');
        }
        state.timer = null;
      }, HIDE_DELAY_MS);
    }

    function placeAndShowForLink(aaaElement, linkRect) {
      if (!aaaElement) return;
      // 显示
      aaaElement.classList.add('visible');
      // 放在链接正下方并水平居中
      const topPosition = linkRect.bottom + window.scrollY;
      let leftPosition = linkRect.left + linkRect.width / 2 + window.scrollX - aaaElement.offsetWidth / 2;

      const screenWidth = window.innerWidth;
      const elementWidth = aaaElement.offsetWidth;
      if (leftPosition + elementWidth > screenWidth) leftPosition = screenWidth - elementWidth;
      else if (leftPosition < 0) leftPosition = 0;

      aaaElement.style.position = 'absolute';
      aaaElement.style.top = `${topPosition}px`;
      aaaElement.style.left = `${leftPosition}px`;
    }

    // ===== 从 chartdev.html 直接载入并挂到 body（保持与原 load.js 一致）=====
    function loadDev() {
      fetch(`../chartdev.html?${Date.now()}`)
        .then(res => {
          if (!res.ok) throw new Error(`加载 chartdev.html 失败：${res.status}`);
          return res.text();
        })
        .then(html => {
          const temp = document.createElement('div');
          temp.innerHTML = html;

          const nodes = temp.querySelectorAll('div[aaa]');
          nodes.forEach(node => {
            const key = node.getAttribute('aaa');
            if (!document.querySelector(`body > div[aaa="${CSS.escape(key)}"]`)) {
              node.style.position = node.style.position || 'absolute';
              document.body.appendChild(node);

              // dev 悬停监听：进入 dev 时保持显示，离开 dev 时可能隐藏
              node.addEventListener('mouseenter', () => {
                const k = node.getAttribute('aaa');   // ✅ 动态读取
                const st = ensureState(k);
                st.el = node;
                st.hoverDev = true;
                node.classList.add('visible');
                if (st.timer) { clearTimeout(st.timer); st.timer = null; }
              });

              node.addEventListener('mouseleave', () => {
                const k = node.getAttribute('aaa');   // ✅ 动态读取
                const st = ensureState(k);
                st.hoverDev = false;
                scheduleHide(k);
              });
            }
          });
        })
        .catch(err => console.error(err));
    }

    // ===== Morph 相关：点击链接时顺滑切换 =====
    let currentKey = null;             // 当前"主"窗口绑定的 key
    let currentEl = null;              // 当前"主"窗口引用的 DOM 元素（会被复用以移动/换内容）
    let isMorphing = false;            // 动画中防抖
    const MORPH_SWAP_DELAY = 40;       // 轻微延迟以确保位置先到再替换内容

    /**
     * 将上一个窗口（currentEl）移动到新链接下方，并把内容替换为新窗口内容
     * @param {HTMLElement} targetEl  目标 key 的 dev 节点（供取内容使用）
     * @param {DOMRect} linkRect      新链接的 rect
     * @param {String} targetKey      目标 key
     */
    function morphToTarget(targetEl, linkRect, targetKey) {
      if (!currentEl || !targetEl || currentEl === targetEl) return;

      // 1) 取消老 key 的隐藏、定时器，并标记当前元素为可见
      if (currentKey) {
        const oldState = ensureState(currentKey);
        if (oldState.timer) { clearTimeout(oldState.timer); oldState.timer = null; }
        oldState.hoverLink = false; // 点击时不强依赖 hover
        oldState.hoverDev = false;
        oldState.el = currentEl;
      }
      currentEl.classList.add('visible');

      // 2) 平滑移动到新位置
      placeAndShowForLink(currentEl, linkRect);

      // 3) 微延迟后替换内容与 key（让用户先看到"飞过去"，再变文字）
      setTimeout(() => {
        // 替换内部内容
        currentEl.innerHTML = targetEl.innerHTML;
        // 更新 aaa key（后续 hover/隐藏依赖）
        currentEl.setAttribute('aaa', targetKey);

        // 隐藏/移除目标原节点，避免重复（保留在 DOM 但不可见即可）
        targetEl.classList.remove('visible');
        targetEl.style.top = '-99999px';
        targetEl.style.left = '-99999px';

        // 更新 currentKey & 状态
        currentKey = targetKey;
        const newState = ensureState(currentKey);
        newState.el = currentEl;
        newState.hoverLink = false;
        newState.hoverDev = false;

        isMorphing = false;
      }, MORPH_SWAP_DELAY);
    }

    /**
     * 以"当前元素优先"的策略显示目标窗口：
     * - 若已有 currentEl：将其移动并替换为目标内容（morph）
     * - 否则正常显示目标元素本身
     */
    function showByMorphOrDirect(targetKey, linkRect) {
      const targetEl = document.querySelector(`div[aaa="${targetKey}"]`);
      if (!targetEl) return;

      // 如果从未有过 currentEl，则以 targetEl 为主
      if (!currentEl) {
        currentEl = targetEl;
        currentKey = targetKey;
        const st = ensureState(targetKey);
        st.el = currentEl;
        st.hoverLink = true;
        if (st.timer) { clearTimeout(st.timer); st.timer = null; }
        placeAndShowForLink(currentEl, linkRect);
        return;
      }

      // 若已有 currentEl 且 key 不同，执行 morph
      if (currentEl && currentKey !== targetKey && !isMorphing) {
        isMorphing = true;
        morphToTarget(targetEl, linkRect, targetKey);
        return;
      }

      // key 相同或正在 morph，就直接更新位置即可
      placeAndShowForLink(currentEl, linkRect);
    }

    // ===== 监听鼠标移动到链接（hover）与点击（click）=====
    function parseInfoKeyFromAnchor(anchor) {
      const url = decodeURIComponent(anchor.href || '');
      const match = url.match(/(info)\(([^)]*)\)/);
      if (!match) return null;
      const params = match[2].split(',').map(param => param.trim().replace(/['"]/g, ''));
      const key = (params.length === 2) ? params.join(',') : params[0];
      return key || null;
    }

    function bindLinkHoverAndClick(target) {
      if (target.dataset.aaaBound) return;
      target.dataset.aaaBound = '1';

      // Hover 行为：与之前一致（但会优先复用 currentEl 以避免两个窗口闪烁）
      target.addEventListener('mouseenter', () => {
        const key = parseInfoKeyFromAnchor(target);
        if (!key) return;
        const state = ensureState(key);
        state.hoverLink = true;
        if (state.timer) { clearTimeout(state.timer); state.timer = null; }
        showByMorphOrDirect(key, target.getBoundingClientRect());
      });

      target.addEventListener('mouseleave', () => {
        const key = parseInfoKeyFromAnchor(target);
        if (!key) return;
        const state = ensureState(key);
        state.hoverLink = false;
        scheduleHide(key);
      });

      // 点击行为：触发"平滑切换"动画（morph 优先）
      target.addEventListener('click', (e) => {
        // 原本我们已阻止 info:info 的默认跳转；此处确保一次
        e.preventDefault();
        const key = parseInfoKeyFromAnchor(target);
        if (!key) return;
        showByMorphOrDirect(key, target.getBoundingClientRect());
      });
    }

    // 捕获全局鼠标移动，动态绑定链接（保持与原有逻辑兼容）
    function checkMouseOnLink(event) {
      const target = event.target;
      if (target.tagName !== 'A') return;
      const key = parseInfoKeyFromAnchor(target);
      if (!key) return;

      // 先绑定 hover/click
      bindLinkHoverAndClick(target);

      // 在 mousemove 命中时也刷新位置与显示，保证体验顺滑
      const aaaElement = currentEl && currentKey === key
        ? currentEl
        : document.querySelector(`div[aaa="${key}"]`);
      if (!aaaElement) return;

      const state = ensureState(key);
      state.el = currentEl || aaaElement;
      state.hoverLink = true;

      // 若当前就是这个 key，用当前元素定位即可
      placeAndShowForLink(state.el, target.getBoundingClientRect());
    }

    // ===== 初始化 =====
    window.addEventListener('resize', resizeKatex);
    window.addEventListener('load', loadMarkdown);
    document.addEventListener('mousemove', checkMouseOnLink);
  </script>
</body>
</html>